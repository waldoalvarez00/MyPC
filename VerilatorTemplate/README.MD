# Verilator_Template

This template project contains an HDL Centipede core, with a supporting verilator-based C++ simulation front-end.

The simulation currently supports the following features in order to make developing cores for MiSTer easier:
- Controllable sim speed with continuous, single and multi-step options
- VGA output is captured and displayed with optional zoom and rotation
- ROM upload (simulating the ioctl elements of HPS)
- Input mappings
- Verilog ```$display``` output is redirected to the UI debug console

## Environment setup

### Windows
- Install WSL2 with Ubuntu
- Install Visual Studio 2022 (Community edition is fine) with the C++ workload

### WSL (verilator)

This project is built and tested with Verilator v5.026. Keep your Verilator install in sync to avoid API/compile errors. 
To install v5.026, run the following commands from a temporary directory:

```
# Prerequisites:
sudo apt-get install git perl python3 make autoconf g++ flex bison ccache
sudo apt-get install libgoogle-perftools-dev numactl perl-doc
sudo apt-get install zlibc zlib1g zlib1g-dev

git clone https://github.com/verilator/verilator

unset VERILATOR_ROOT
cd verilator
git pull
git checkout v5.026
autoconf
./configure
make -j `nproc`
sudo make install
```

## Project structure

The ```/verilator``` directory contains all simulation-related resources.  Some important resources are:

- ```/verilator/centipede_sim.v``` - Surrogate *top* module to host the HDL code
- ```/verilator/verilate.sh``` - Bash script which runs verilator against the HDL files in ```/rtl```
- ```/verilator/obj_dir/``` - Contains the C++ source generated by verilator 
- ```/verilator/sim/``` - Contains the C++ source files to host the simulation
- ```/verilator/sim/imgui``` - Contains the *Dear Imgui* C++ includes
- ```/verilator/sim/vinc``` - Contains the *Verilator* C++ includes

### Building and running the simulation
Run ```verilate.sh``` after changes to any HDL code.  Visual Studio will then automatically re-build on the next run.

> IMPORTANT: Run the simulation project in Release mode or your framerate will be very disappointing! 


### Simulator controls (keyboard)
The simulator maps keyboard input onto the 12-bit `inputs` bus (see `verilator/sim_main.cpp`):
- Arrows: Up / Down / Left / Right
- Space: Fire 1
- 1 / 2: Start 1 / Start 2
- 5 / 6 / 7: Coin 1 / Coin 2 / Coin 3
- P: Pause
Windows uses DirectInput; Linux/WSL uses SDL2. Customize the bindings via the `SetMapping` calls in `verilator/sim_main.cpp`.


### Signal inspection
You can inspect RTL signals in two ways:
- VCD tracing: enable VCD export from the Trace window in the simulator UI (or set `Trace = true` and a file name in `verilator/sim_main.cpp`). The Verilated model dumps a VCD (e.g. `sim.vcd`) that you can open in GTKWave or another viewer. If a signal is missing, mark it `/*verilator public*/` or `public_flat` in the RTL and regenerate via `verilate.sh` so it is included in the trace.
- Live ImGui panel: since `Vtop` is in-process, you can read public signals (e.g. `top->rootp->...`) and display them in a custom ImGui window. To expose internal nets, mark them `/*verilator public*/` in the RTL and rerun `verilate.sh`, then render them from C++.
