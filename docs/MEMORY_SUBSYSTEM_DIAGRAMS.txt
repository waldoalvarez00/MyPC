=============================================================================
MEMORY SUBSYSTEM ARCHITECTURE DIAGRAMS
=============================================================================

=============================================================================
1. OVERALL MEMORY SYSTEM ARCHITECTURE
=============================================================================

┌──────────────────────────────────────────────────────────────────────────┐
│                          MEMORY ACCESS HIERARCHY                         │
├──────────────────────────────────────────────────────────────────────────┤
│                                                                           │
│  ┌────────────────────────────────────────────────────────────────────┐  │
│  │                        CPU CORE                                     │  │
│  │  ┌──────────────────────────────────────────────────────────────┐  │  │
│  │  │  Instruction Fetch Unit      │      Data Load/Store Unit     │  │  │
│  │  │  • 16-bit instruction prefetch                               │  │  │
│  │  │  • Sequential code following                                 │  │  │
│  │  │                                                              │  │  │
│  │  │  • MAR/MDR registers                                         │  │  │
│  │  │  • Segment:Offset addressing                                │  │  │
│  │  └──────────────────────────────────────────────────────────────┘  │  │
│  │            │                                                │        │  │
│  │            └────────────────────┬─────────────────────────┘        │  │
│  │                                  │                                  │  │
│  │                         MemArbiter (CPU)                           │  │
│  │                    Arbitrates between:                             │  │
│  │                    • Instruction bus (a)                           │  │
│  │                    • Data bus (b)                                  │  │
│  │                    Priority: Data > Instruction                    │  │
│  │                                  │                                  │  │
│  │                                  ▼                                  │  │
│  │                    ┌─────────────────────────┐                     │  │
│  │                    │  16KB L1 Cache (8KB)    │                     │  │
│  │                    │ • Direct-mapped         │                     │  │
│  │                    │ • 512 lines × 8 words   │                     │  │
│  │                    │ • Write-through         │                     │  │
│  │                    │ • 80-90% hit rate       │                     │  │
│  │                    └─────────────────────────┘                     │  │
│  │                                  │                                  │  │
│  │                                  ▼                                  │  │
│  └──────────────────────────────────────────────────────────────────┘  │
│                                  │                                       │
└──────────────────────────────────┼───────────────────────────────────────┘
                                    │
                ┌───────────────────┴──────────────────┐
                │                                      │
        ┌──────▼──────┐                        ┌──────▼───────┐
        │  DMA        │                        │  VGA         │
        │  • Floppy   │                        │  • Framebuffer
        │  • SD Card  │                        │  • Prefetch   
        └──────┬──────┘                        └──────┬───────┘
               │                                      │
               └───────────────────┬──────────────────┘
                                   │
                            DMAArbiter
                   Arbitrates: CPU+Inst+Data vs DMA
                   Priority: DMA when pending
                                   │
                                   ▼
                          ┌──────────────────┐
                          │ MemArbiterExtend │
                          │ Arbitrates:      │
                          │ CPU+DMA vs VGA   │
                          │ Policy: Round-   │
                          │ robin with       │
                          │ fairness         │
                          └──────────────────┘
                                   │
                                   ▼
                     ┌──────────────────────────┐
                     │   SDRAMController        │
                     │ • 64MB SDRAM (25 MHz)    │
                     │ • 4 banks, 8K rows       │
                     │ • Row-buffer management  │
                     │ • Auto-refresh           │
                     │ • CAS Latency = 2 cycles │
                     └──────────────────────────┘
                                   │
                                   ▼
                     ┌──────────────────────────┐
                     │   64MB ISSI IS45S16160G  │
                     │   • 16-bit data bus      │
                     │   • 50 MB/s theoretical  │
                     │   • 37 MB/s practical    │
                     └──────────────────────────┘

=============================================================================
2. MEMORY ACCESS TIMING DIAGRAM
=============================================================================

                         CPU MEMORY REQUEST TIMING
                         ═══════════════════════════

Cycle:   0      1      2      3      4      5      6      7
         │      │      │      │      │      │      │      │
CPU:     ┌──────┐
         │ REQ  │
         └──────┘
         
Arbiter: ┌──────┐
         │Idle  │ [Grant Asserted]  [Waiting for ACK]
         └──────┘   ▲
         
SDRAM:                   ┌──────┐
                         │ Cmd  │ [CAS Latency = 2 cycles]
                         └──────┘   ▲
                                    │
Data:                                   ┌──────┐
                                        │Data  │
                                        └──────┘


BEST CASE (Cache Hit): 1-2 cycles
───────────────────────────────
Access  ├─1─┤ ├─data─┤  ← Combined: Tag match + Data out
        └─────────────┘

WORST CASE (Cache Miss + Dirty Line): 8-16 cycles
──────────────────────────────────────────────────
Miss    ├─detect─┤
Flush   ├─────────8 cycles to memory────────┤  ← Write old line
Fill    ├─────────8 cycles from memory──────┤  ← Read new line
Ready   ├────────────────────────────────────┤

ROW MISS (No Cache): 5-8 cycles
────────────────────────────────
Precharge  ├─2─┤
Activate   ├─2─┤
CAS        ├─2─┤
Data       ├─2─┤
Total:     ├────────────┤

=============================================================================
3. BANDWIDTH ALLOCATION DIAGRAM
=============================================================================

          SDRAM BANDWIDTH ALLOCATION @ 25 MHz
          ════════════════════════════════════

Total Available: 50 MB/s (16-bit × 25 MHz)
                │
                ├─ VGA Framebuffer: 30.7 MB/s (61%)
                │  ├─ 640×400 @ 60 Hz
                │  ├─ 16-bit color
                │  ├─ ~512×16 prefetch buffer
                │
                └─ CPU+DMA Available: 19.3 MB/s (39%)
                   ├─ CPU Data: 12-15 MB/s (est.)
                   ├─ CPU Instructions: 5-7 MB/s (est.)
                   └─ DMA (Floppy/SD): 0-3 MB/s (shared)

MEMORY ARBITRATION IMPACT:
──────────────────────────
Theoretical:    50 MB/s
Practical:      37 MB/s (accounting for SDRAM timing)
With Cache:     28.6 MB/s (effective to CPU @ 80% hit)
VGA Share:      30.7 MB/s (dedicated/required)
CPU Available:  19.3 MB/s (after VGA)


LATENCY IMPACT ON THROUGHPUT:
─────────────────────────────

Without Cache:
└─ Average: 4.25 cycles per access
└─ Bandwidth: 50 MB/s ÷ 4.25 = 11.8 MB/s effective

With Cache (80% hit):
└─ Average: 0.8(1 cycle) + 0.2(8 cycles) = 1.8 cycles
└─ Bandwidth: 50 MB/s ÷ 1.8 = 27.8 MB/s effective

=============================================================================
4. ARBITRATION STATE MACHINES
=============================================================================

Level 1: MemArbiter (CPU Instruction vs Data)
──────────────────────────────────────────────

        ┌─────────────────────────────────────┐
        │           IDLE (grant=0)            │
        │ Waiting for a_m_access OR b_m_access│
        └────────────────┬────────────────────┘
                         │
          ┌──────────────┴──────────────┐
          │                             │
          ▼ b_m_access=1            ▼ a_m_access=1
        ┌──────────────────┐        ┌──────────────────┐
        │  GRANT DATA BUS  │        │ GRANT INSTR BUS  │
        │  (grant_to_b=1)  │        │ (grant_to_b=0)   │
        │  grant_active=1  │        │ grant_active=1   │
        └────────┬─────────┘        └────────┬─────────┘
                 │                          │
                 └──────────────┬───────────┘
                                │
                        q_m_ack received
                                │
                    ┌───────────▼────────────┐
                    │ Return to IDLE         │
                    │ grant_active=0         │
                    │ grant_to_b=X (latched) │
                    └───────────┬────────────┘
                                │
                    ┌───────────▼────────────┐
                    │ Check next request     │
                    │ Priority: Data > Instr │
                    └───────────────────────┘


Level 3: MemArbiterExtend (CPU+DMA vs VGA)
─────────────────────────────────────────────

        ┌──────────────────────────────┐
        │      IDLE                    │
        │ Check pending requests       │
        └────────────┬─────────────────┘
                     │
          ┌──────────┴──────────┐
          │                     │
     If last_served=A:     If last_served=B:
     Give priority to B    Give priority to A
          │                     │
          ▼                     ▼
    ┌──────────────┐        ┌──────────────┐
    │ SERVING_B    │        │ SERVING_A    │
    │ servingA=0   │        │ servingA=1   │
    │ grant_active │        │ grant_active │
    └──────┬───────┘        └──────┬───────┘
           │                       │
           └───────────┬───────────┘
                       │
                sdram_m_ack received
                       │
            ┌──────────▼───────────┐
            │ Update last_served   │
            │ Return to IDLE       │
            │ Implement fairness   │
            └──────────┬───────────┘
                       │
        ┌──────────────▼──────────────┐
        │ Round-robin to prevent      │
        │ one master from starving    │
        │ the other                   │
        └─────────────────────────────┘

=============================================================================
5. CACHE ORGANIZATION & ADDRESS MAPPING
=============================================================================

      19-BIT ADDRESS DECOMPOSITION
      ═════════════════════════════

    [Tag (7)][Index (9)][Offset (3)][Byte (1)]
    ├──────┤├────────┤├────────┤├─┤
    │      ││        ││        ││ └─ Byte offset in word
    │      ││        ││        │└──── Offset in line (8 words)
    │      ││        │└────────┴───── Line index (512 lines)
    │      │└────────────────────────── Tag (uniqueness check)
    │      └──────────────────────────── Cache disable
    └─────────────────────────────────── Sector

    19-bit address space = 512 KB (addressable by cache frontend)
    25-bit physical address = 32 MB (from CPU to SDRAM)


CACHE MEMORY ORGANIZATION:
──────────────────────────

    512 Cache Lines × 8 Words/Line × 2 Bytes/Word = 8 KB Total

    ┌─────────────────────────────────┐
    │   Index 0                       │  ┌─ Tag RAM (7 bits)
    │   ┌─ [Tag][Valid][Dirty]        │  │  Contains tag for matching
    │   │   Word 0 (16-bit)  ◄────────┼──┼─ Valid RAM (1 bit)
    │   │   Word 1 (16-bit)           │  │  Valid bit for line
    │   │   ...                       │  │
    │   │   Word 7 (16-bit)           │  ├─ Dirty RAM (1 bit)
    │   │                             │  │  Marks modified lines
    │   ├─ [Tag][Valid][Dirty]        │  │
    │   │   Word 0 (16-bit)           │  └─ Data RAM (16×8 bits)
    │   │   Word 1 (16-bit)           │     Actual cache data
    │   │   ...                       │
    │   │   Word 7 (16-bit)           │
    │   │                             │
    │   ...                           │
    │   Index 511                     │
    │   ┌─ [Tag][Valid][Dirty]        │
    │   │   Word 0 (16-bit)           │
    │   │   ...                       │
    │   │   Word 7 (16-bit)           │
    │   └─────────────────────────────┘
    │
    └─ Total Capacity: 512 × 8 × 2 = 8,192 bytes


CACHE LINE FILL/FLUSH:
──────────────────────

    A cache miss requires an 8-word line transfer:

    Cycle 1: Address Word 0 [3:1] = 000
    Cycle 2: Address Word 1 [3:1] = 001
    Cycle 3: Address Word 2 [3:1] = 010
    Cycle 4: Address Word 3 [3:1] = 011
    Cycle 5: Address Word 4 [3:1] = 100
    Cycle 6: Address Word 5 [3:1] = 101
    Cycle 7: Address Word 6 [3:1] = 110
    Cycle 8: Address Word 7 [3:1] = 111

    8 memory cycles per line (16 bytes transferred)

=============================================================================
6. SDRAM TIMING STATE MACHINE
=============================================================================

INITIALIZATION SEQUENCE:
───────────────────────

    Start
      │
      ├─ tReset (2500 cycles @ 25MHz = 100µs)  ← Wait for chip ready
      │
      ├─ tRP (2 cycles) ─────► Precharge All
      │
      ├─ tRC (8 cycles) ─────► Auto-Refresh #1
      │
      ├─ tRC (8 cycles) ─────► Auto-Refresh #2
      │
      ├─ tMRD (2 cycles) ────► Mode Register Set (Burst=2, CAS=2)
      │
      ▼
    READY (config_done=1)


TYPICAL READ ACCESS (Row Hit):
──────────────────────────────

    Start (row already open)
      │
      ├─ Issue READ command
      │
      ├─ tRCD (2 cycles) = 80 ns minimum before data available
      │
      ├─ CAS Latency (2 cycles) = 80 ns data delivery time
      │
      ▼
    Data valid on bus (h_rdata)
    
    Total latency: 4-5 cycles for row hit


TYPICAL READ ACCESS (Row Miss):
────────────────────────────────

    Start (different row needed)
      │
      ├─ Issue PRECHARGE command
      │
      ├─ tRP (2 cycles) = 80 ns precharge time
      │
      ├─ Issue ACTIVATE command
      │
      ├─ tRCD (2 cycles) = 80 ns row-to-column delay
      │
      ├─ Issue READ command
      │
      ├─ CAS Latency (2 cycles) = 80 ns data delivery
      │
      ▼
    Data valid (h_rdata)
    
    Total latency: 8-9 cycles for row miss


AUTO-REFRESH:
──────────────

    Every ~195 cycles (7,813 ns @ 25 MHz):
    
    Precharge ──► tRP (2) ──► Refresh ──► tRC (8) ──► Ready

=============================================================================
7. BOTTLENECK SEVERITY MATRIX
=============================================================================

SEVERITY CHART (Impact vs Frequency):

High Frequency │ Serialized      │
               │ Memory Access   │
               │ (CRITICAL)      │
               │                 │
Medium         │ SDRAM Row Miss  │ Cache Insufficient │ Clock Frequency
Frequency      │ Penalty (HIGH)  │ (MEDIUM)           │ Too Low (MEDIUM)
               │                 │                    │
               │                 │ VGA Bandwidth      │ Write Throughput
Low Frequency  │                 │ Sharing (LOW)      │ Limited (LOW)
               │                 │
               └─────────────────┴────────────────────┴───────────────────┘
               Low           Medium             High
               Performance Impact Magnitude

CUMULATIVE IMPACT:

  System Performance Limit:
  ═══════════════════════════

  100% ┌─────────────────────────────────────┐
       │ Theoretical Maximum (no constraints)│
       ├─────────────────────────────────────┤
   70% │ After: Serialization (-30%)         │
       ├─────────────────────────────────────┤
   63% │ After: SDRAM Row Miss (-7%)         │
       ├─────────────────────────────────────┤
   60% │ After: Clock Frequency (-3%)        │
       ├─────────────────────────────────────┤
       │ ACTUAL ACHIEVABLE PERFORMANCE       │
       │ → 40% CPU utilization on real tasks │
   40% │ → 60% time waiting for memory       │
       └─────────────────────────────────────┘

