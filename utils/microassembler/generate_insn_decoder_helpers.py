#!/usr/bin/env python3

"""
Generate InstructionDefinitions.sv helper functions for InsnDecoder.
This analyzes the microcode files to determine which opcodes have modrm bytes
and which have immediates, then generates the helper functions.
"""

import os
import sys
import re
import pystache

def analyze_microcode_files(microcode_dir):
    """Analyze microcode .us files to extract opcode information."""

    # Track opcodes and their properties
    opcodes_with_modrm = set()
    opcodes_with_immediates = {}  # opcode -> (count, sizes)

    # Regex patterns
    at_directive = re.compile(r'\.at\s+(0x[0-9a-fA-F]+);')
    modrm_usage = re.compile(r'\b(modrm_start|ra_modrm_rm_reg|jmp_rm_reg_mem|jmp_dispatch_reg)\b')
    immediate_usage = re.compile(r'\b(b_sel\s+IMMEDIATE|IMMEDIATE)\b')

    current_opcode = None

    # Process all .us files
    for filename in sorted(os.listdir(microcode_dir)):
        if not filename.endswith('.us'):
            continue

        filepath = os.path.join(microcode_dir, filename)

        with open(filepath, 'r') as f:
            for line in f:
                # Check for .at directive
                at_match = at_directive.search(line)
                if at_match:
                    current_opcode = int(at_match.group(1), 16)
                    continue

                # Skip if no current opcode
                if current_opcode is None:
                    continue

                # Check for modrm usage
                if modrm_usage.search(line):
                    opcodes_with_modrm.add(current_opcode)

                # Check for immediate usage
                if immediate_usage.search(line):
                    if current_opcode not in opcodes_with_immediates:
                        opcodes_with_immediates[current_opcode] = 1
                    # Could analyze further for count and sizes, but default to 1 immediate

    return opcodes_with_modrm, opcodes_with_immediates


def generate_instruction_definitions(output_file, template_file, modrm_opcodes, immediate_info):
    """Generate InstructionDefinitions.sv helper functions."""

    # Build the output directly
    output_lines = []

    # Copyright header
    output_lines.append("// Copyright Jamie Iles, 2018")
    output_lines.append("//")
    output_lines.append("// This file is part of s80x86.")
    output_lines.append("//")
    output_lines.append("// AUTO-GENERATED by generate_insn_decoder_helpers.py")
    output_lines.append("// Do not edit manually!")
    output_lines.append("")

    # Function 1: insn_has_modrm
    output_lines.append("function logic insn_has_modrm;")
    output_lines.append("    input logic [7:0] opcode;")
    output_lines.append("")
    output_lines.append("    casez (opcode)")
    for opc in sorted(modrm_opcodes):
        output_lines.append(f"    8'h{opc:02x}: insn_has_modrm = 1'b1;")
    output_lines.append("    default: insn_has_modrm = 1'b0;")
    output_lines.append("    endcase")
    output_lines.append("endfunction")
    output_lines.append("")

    # Function 2: insn_immed_count
    output_lines.append("function logic [1:0] insn_immed_count;")
    output_lines.append("    input logic [7:0] opcode;")
    output_lines.append("    input logic [2:0] modrm_reg;")
    output_lines.append("")
    output_lines.append("    unique casez ({opcode, modrm_reg})")

    # Add entries for opcodes with immediates
    for opc in range(256):
        if opc in immediate_info:
            immed_count = immediate_info[opc]
            output_lines.append(f"    {{8'h{opc:02x}, 3'b???}}: insn_immed_count = 2'd{immed_count};")

    output_lines.append("    default: insn_immed_count = 2'b0;")
    output_lines.append("    endcase")
    output_lines.append("endfunction")
    output_lines.append("")

    # Function 3: insn_immed_is_8bit
    output_lines.append("function logic insn_immed_is_8bit;")
    output_lines.append("    input logic [7:0] opcode;")
    output_lines.append("    input logic [2:0] modrm_reg;")
    output_lines.append("    input logic immed_num;")
    output_lines.append("")
    output_lines.append("    unique casez ({opcode, modrm_reg})")

    # Add entries for opcodes with immediates
    for opc in range(256):
        if opc in immediate_info:
            immed_count = immediate_info[opc]
            # Assume all immediates are 16-bit by default (bit pattern: 01 for 1 immed, 11 for 2 immeds)
            if immed_count == 1:
                immediate_sizes = "2'b01"
            elif immed_count == 2:
                immediate_sizes = "2'b11"
            else:
                immediate_sizes = "2'b00"
            output_lines.append(f"    {{8'h{opc:02x}, 3'b???}}: insn_immed_is_8bit = ~|({immediate_sizes} & (2'b1 << immed_num));")

    output_lines.append("    default: insn_immed_is_8bit = 1'b0;")
    output_lines.append("    endcase")
    output_lines.append("endfunction")
    output_lines.append("")

    # Write output
    with open(output_file, 'w') as f:
        f.write('\n'.join(output_lines))

    print(f"Generated {output_file}")
    print(f"  - {len(modrm_opcodes)} opcodes with modrm bytes")
    print(f"  - {len([opc for opc in immediate_info if immediate_info[opc] > 0])} opcodes with immediates")


def main():
    # Paths
    here = os.path.dirname(os.path.abspath(__file__))
    microcode_dir = os.path.join(here, 'microcode')
    template_file = os.path.join(here, '..', '..', 'Quartus', 'rtl', 'CPU', 'InstructionDefinitions.sv.templ')
    output_file = os.path.join(here, '..', '..', 'Quartus', 'rtl', 'CPU', 'InstructionDefinitions_helpers.sv')

    print("=" * 70)
    print("Generating InsnDecoder Helper Functions")
    print("=" * 70)

    # Analyze microcode files
    print(f"Analyzing microcode files in {microcode_dir}...")
    modrm_opcodes, immediate_info = analyze_microcode_files(microcode_dir)

    # Generate output
    generate_instruction_definitions(output_file, template_file, modrm_opcodes, immediate_info)

    print("=" * 70)
    print("Generation complete!")
    print("=" * 70)

    return 0


if __name__ == '__main__':
    sys.exit(main())
