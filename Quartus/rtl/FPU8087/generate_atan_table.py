#!/usr/bin/env python3
"""
Generate Arctangent Lookup Table for CORDIC

This script generates a 64-entry ROM containing atan(2^-i) values
in IEEE 754 extended precision (80-bit) format for CORDIC iterations.

Output: FPU_Atan_Table.v Verilog module
"""

import math
import struct

def float_to_fp80(value):
    """
    Convert Python float to 80-bit extended precision format.

    IEEE 754 Extended Precision (80-bit):
    [79]    : Sign bit (1 bit)
    [78:64] : Exponent (15 bits, biased by 16383)
    [63]    : Integer bit (explicit)
    [62:0]  : Mantissa (63 bits)

    Returns: 80-bit integer representation
    """
    if value == 0.0:
        return 0

    # Extract sign
    sign = 1 if value < 0 else 0
    value = abs(value)

    # Handle special cases
    if math.isinf(value):
        # Infinity: exp=all 1s, mantissa=0
        return (sign << 79) | (0x7FFF << 64)
    if math.isnan(value):
        # NaN: exp=all 1s, mantissa!=0
        return (sign << 79) | (0x7FFF << 64) | 1

    # Get exponent and mantissa
    exp = math.floor(math.log2(value))
    mantissa = value / (2.0 ** exp)

    # Convert mantissa to 64-bit integer (with explicit leading bit)
    # The integer bit is explicit in FP80
    mantissa_int = int(mantissa * (2 ** 63))

    # Bias the exponent
    exp_biased = (exp + 16383) & 0x7FFF

    # Check for overflow/underflow
    if exp_biased <= 0:
        # Denormalized or underflow
        exp_biased = 0
        mantissa_int = int((value / (2.0 ** (1 - 16383))) * (2 ** 63))
    elif exp_biased >= 0x7FFF:
        # Overflow to infinity
        exp_biased = 0x7FFF
        mantissa_int = 0

    # Pack into 80-bit value
    fp80 = (sign << 79) | (exp_biased << 64) | (mantissa_int & 0xFFFFFFFFFFFFFFFF)

    return fp80


def generate_atan_table():
    """Generate arctangent values for CORDIC iterations"""
    table = []

    print("Generating arctangent table for CORDIC...")
    print(f"{'Index':<6} {'2^-i':<20} {'atan(2^-i) rad':<25} {'atan(2^-i) deg':<20} {'FP80 (hex)'}")
    print("=" * 110)

    for i in range(64):
        # Compute atan(2^-i)
        angle_rad = math.atan(2.0 ** (-i))
        angle_deg = math.degrees(angle_rad)
        input_val = 2.0 ** (-i)

        # Convert to FP80
        fp80_value = float_to_fp80(angle_rad)

        # Store entry
        table.append((i, input_val, angle_rad, angle_deg, fp80_value))

        # Print
        print(f"{i:<6} {input_val:<20.15e} {angle_rad:<25.20f} {angle_deg:<20.15f} {fp80_value:020X}")

    return table


def generate_verilog_module(table, output_file):
    """Generate Verilog ROM module"""

    with open(output_file, 'w') as f:
        f.write("`timescale 1ns / 1ps\n\n")
        f.write("//=====================================================================\n")
        f.write("// Arctangent Lookup Table for CORDIC\n")
        f.write("//\n")
        f.write("// This ROM contains 64 entries of atan(2^-i) values in 80-bit\n")
        f.write("// IEEE 754 extended precision format.\n")
        f.write("//\n")
        f.write("// Used by CORDIC algorithms for computing trigonometric functions:\n")
        f.write("// - sin/cos (rotation mode)\n")
        f.write("// - atan (vectoring mode)\n")
        f.write("// - tan (rotation mode + division)\n")
        f.write("//\n")
        f.write("// Format: atan(2^-index) where index ∈ [0, 63]\n")
        f.write("//\n")
        f.write("// Auto-generated by generate_atan_table.py\n")
        f.write("//=====================================================================\n\n")

        f.write("module FPU_Atan_Table(\n")
        f.write("    input wire [5:0] index,        // Index (0-63)\n")
        f.write("    output reg [79:0] atan_value   // atan(2^-index) in FP80 format\n")
        f.write(");\n\n")

        f.write("    // Arctangent lookup table\n")
        f.write("    always @(*) begin\n")
        f.write("        case (index)\n")

        for i, input_val, angle_rad, angle_deg, fp80_value in table:
            # Format FP80 value with underscores for readability
            fp80_hex = f"{fp80_value:020X}"
            fp80_formatted = f"{fp80_hex[0:4]}_{fp80_hex[4:20]}"

            f.write(f"            6'd{i:2d}: atan_value = 80'h{fp80_formatted}; ")
            f.write(f"// atan(2^-{i:2d}) = {angle_rad:22.20f} rad ({angle_deg:8.5f}°)\n")

        f.write("            default: atan_value = 80'h0; // Should never occur\n")
        f.write("        endcase\n")
        f.write("    end\n\n")

        f.write("endmodule\n\n")

        # Add verification notes
        f.write("//=====================================================================\n")
        f.write("// Verification Notes\n")
        f.write("//=====================================================================\n")
        f.write("//\n")
        f.write("// Key values for reference:\n")
        f.write("//\n")

        # Print key values
        for i in [0, 1, 2, 3, 4, 10, 20, 30, 40, 50, 63]:
            _, input_val, angle_rad, angle_deg, fp80_value = table[i]
            f.write(f"// atan(2^-{i:2d}) = {angle_rad:22.20f} rad\n")

        f.write("//\n")
        f.write("// The convergence domain of CORDIC is approximately [-99.7°, +99.7°]\n")
        f.write("// or [-1.74 rad, +1.74 rad].\n")
        f.write("//\n")
        f.write("// For angles outside this range, use range reduction:\n")
        f.write("// - Map to [-π, π] using modulo 2π\n")
        f.write("// - Use trig identities to map to [-π/4, π/4] for best accuracy\n")
        f.write("//\n")
        f.write("// Sum of all atan values ≈ 1.74328 radians ≈ 99.88°\n")
        f.write("// This represents the maximum angle that can be reduced to zero\n")
        f.write("// in rotation mode CORDIC.\n")
        f.write("//=====================================================================\n")


def main():
    # Generate table
    table = generate_atan_table()

    # Generate Verilog module
    output_file = "FPU_Atan_Table.v"
    generate_verilog_module(table, output_file)

    print(f"\nGenerated {output_file}")

    # Calculate sum of all atan values (convergence domain check)
    total_angle = sum(angle_rad for _, _, angle_rad, _, _ in table)
    print(f"\nSum of all atan values: {total_angle:.10f} radians ({math.degrees(total_angle):.5f}°)")
    print(f"This is the CORDIC convergence domain: approximately ±{total_angle:.5f} rad")


if __name__ == '__main__':
    main()
