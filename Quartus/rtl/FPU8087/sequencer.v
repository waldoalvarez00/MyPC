`timescale 1ns / 1ps

//---------------------------------------------------------------------
// Overall Opcode definitions.
`define OPCODE_NOP    4'h0
`define OPCODE_EXEC   4'h1
`define OPCODE_JUMP   4'h2
`define OPCODE_CALL   4'h3
`define OPCODE_RET    4'h4
`define OPCODE_HALT   4'hF

//---------------------------------------------------------------------
// Micro–operation codes (used when overall opcode == EXEC).
`define MOP_LOAD            4'h1  // Load from CPU bus into temp_reg.
`define MOP_STORE           4'h2  // Store from temp_reg to CPU bus.
`define MOP_SET_CONST       4'h3  // Set math constant index (from immediate).
`define MOP_ACCESS_CONST    4'h4  // Load constant (via math_const_index) into temp_fp.
`define MOP_ADD_SUB         4'h5  // FP add/subtract (operands preloaded).
`define MOP_SHIFT_LEFT_BIT  4'h6  // Shift temp_reg left by an immediate value.
`define MOP_LOOP_INIT       4'h7  // Initialize loop register with immediate.
`define MOP_LOOP_DEC        4'h8  // Decrement loop register and jump if nonzero.
`define MOP_ABS             4'h9  // Compute absolute value of temp_fp.
`define MOP_ROUND           4'hA  // Round temp_fp (using immediate for rounding mode).
`define MOP_NORMALIZE       4'hB  // Normalize temp_fp.
`define MOP_READ_STATUS     4'hC  // Read FPU_Status_Word into temp_reg.
`define MOP_READ_CONTROL    4'hD  // Read FPU_Control_Word_Register into temp_reg.
`define MOP_READ_TAG        4'hE  // Read FPU_Tag_Register into temp_reg.
`define MOP_WRITE_STATUS    4'hF  // Write temp_reg (lower 16 bits) into FPU_Status_Word.

//---------------------------------------------------------------------
// The MicroSequencer module.
module MicroSequencer (
    input         clk,
    input         reset,
    input         start,               // Signal to start microprogram execution.
    input  [3:0]  micro_program_index, // Index into the microprogram table.
    input  [63:0] cpu_data_in,         // Data from the CPU bus.
    output reg [63:0] cpu_data_out,     // Data to the CPU bus.
    output reg    instruction_complete   // Signals when the microprogram is done.
);

    // FSM state definitions.
    localparam STATE_IDLE   = 3'd0;
    localparam STATE_FETCH  = 3'd1;
    localparam STATE_DECODE = 3'd2;
    localparam STATE_EXEC   = 3'd3;
    
    reg [2:0] state;
    
    // 16-bit microprogram counter (addresses up to 65,536 instructions).
    reg [15:0] pc;
    
    // Microinstruction format:
    // { opcode[31:28], micro_op[27:24], immediate[23:16], next_addr[15:0] }.
    reg [31:0] microinstruction;
    wire [3:0] opcode     = microinstruction[31:28];
    wire [3:0] micro_op   = microinstruction[27:24];
    wire [7:0] immediate  = microinstruction[23:16];
    wire [15:0] next_addr = microinstruction[15:0];
    
    // Enlarged call stack: 16 entries.
    reg [15:0] call_stack [0:15];
    reg [3:0] call_sp;
    
    // Loop register (for for–loops).
    reg [31:0] loop_reg;
    
    // Temporary registers.
    reg [63:0] temp_reg;         // General purpose temporary storage.
    reg [4:0]  math_const_index;  // Index for the math constants ROM.
    reg [79:0] temp_fp;          // 80-bit temporary FP register.
    reg [79:0] temp_fp_a, temp_fp_b; // Operands for the FP Add/Sub unit.
    
    //-----------------------------------------------------------------
    // Microprogram Table: maps a 4-bit index (from external logic)
    // to a starting ROM address. (This table would be generated by a
    // micro assembler in a full design.)
    reg [15:0] micro_program_table [0:15];
    initial begin
        micro_program_table[0] = 16'd0;
        micro_program_table[1] = 16'd100;
        micro_program_table[2] = 16'd200;
        micro_program_table[3] = 16'd300;
        // ... additional entries as needed.
    end
    
    //-----------------------------------------------------------------
    // Large Microcode ROM: 4096 x 32-bit instructions.
    reg [31:0] microcode_rom [0:4095];
    initial begin
        // Example microprogram sequence:
        // Address 0: LOAD from CPU bus into temp_reg.
        microcode_rom[0] = {`OPCODE_EXEC, `MOP_LOAD, 8'd0, 16'd1};
        // Address 1: SET_CONST – set math constant index to immediate value 5.
        microcode_rom[1] = {`OPCODE_EXEC, `MOP_SET_CONST, 8'd5, 16'd2};
        // Address 2: ACCESS_CONST – load constant from math constants ROM into temp_fp.
        microcode_rom[2] = {`OPCODE_EXEC, `MOP_ACCESS_CONST, 8'd0, 16'd3};
        // Address 3: STORE – send temp_reg to the CPU bus.
        microcode_rom[3] = {`OPCODE_EXEC, `MOP_STORE, 8'd0, 16'd4};
        // Address 4: READ FPU Status into temp_reg.
        microcode_rom[4] = {`OPCODE_EXEC, `MOP_READ_STATUS, 8'd0, 16'd5};
        // Address 5: READ FPU Control into temp_reg.
        microcode_rom[5] = {`OPCODE_EXEC, `MOP_READ_CONTROL, 8'd0, 16'd6};
        // Address 6: READ FPU Tag into temp_reg.
        microcode_rom[6] = {`OPCODE_EXEC, `MOP_READ_TAG, 8'd0, 16'd7};
        // Address 7: WRITE – write temp_reg to FPU Status.
        microcode_rom[7] = {`OPCODE_EXEC, `MOP_WRITE_STATUS, 8'd0, 16'd8};
        // Address 8: HALT – finish the microprogram.
        microcode_rom[8] = {`OPCODE_HALT, 4'd0, 8'd0, 16'd0};
        
        // Example loop microprogram starting at address 100.
        microcode_rom[100] = {`OPCODE_EXEC, `MOP_LOOP_INIT, 8'd3, 16'd101}; // Initialize loop counter to 3.
        microcode_rom[101] = {`OPCODE_EXEC, `MOP_ADD_SUB, 8'd0, 16'd102};   // Example FP add/sub.
        microcode_rom[102] = {`OPCODE_EXEC, `MOP_LOOP_DEC, 8'd0, 16'd101};    // Decrement loop and jump if nonzero.
        microcode_rom[103] = {`OPCODE_HALT, 4'd0, 8'd0, 16'd0};
        
        // Additional microinstructions would be defined here.
    end
    
    //-----------------------------------------------------------------
    // Instantiate the math constants ROM (32 locations of 80 bits each).
    wire [79:0] math_const_out;
    mathconstantsrom_32x80bits mathconst_rom_inst (
        .address(math_const_index),
        .data(math_const_out)
    );
    
    //-----------------------------------------------------------------
    // Instantiate FPU registers.
    // (These modules are assumed to have been modified to provide
    // a read interface.)
    wire [15:0] fpu_status;
    FPU_Status_Word fpu_status_inst (
        .status_word(fpu_status)
    );
    
    wire [15:0] fpu_control;
    FPU_Control_Word_Register fpu_control_inst (
        .control_word(fpu_control)
    );
    
    wire [15:0] fpu_tag;
    FPU_Tag_Register fpu_tag_inst (
        .tag_register(fpu_tag)
    );
    
    // For writing to FPU_Status_Word, we assume an internal register.
    reg [15:0] fpu_status_reg;
    always @(posedge clk or posedge reset) begin
        if (reset)
            fpu_status_reg <= 16'd0;
        else begin
            // fpu_status_reg is updated via the MOP_WRITE_STATUS micro–op.
        end
    end
    
    //-----------------------------------------------------------------
    // Instantiate the FPU Add/Sub unit.
    wire [79:0] addsub_result;
    wire cmp_equal, cmp_less, cmp_greater;
    reg fpu_invert_operand_b;
    FPU_AddSub_Comp_Unit fpu_addsub_inst (
        .clk(clk),
        .invert_operand_b(fpu_invert_operand_b),
        .operand_a(operand_a),
        .operand_b(operand_b),
        .result(addsub_result),
        .cmp_equal(cmp_equal),
        .cmp_less(cmp_less),
        .cmp_greater(cmp_greater)
    );
    reg [79:0] operand_a, operand_b;
    
    //-----------------------------------------------------------------
    // Instantiate a bit shifter for left shifts.
    wire [63:0] shift_left_out;
    reg [63:0] shift_left_in;
    reg [2:0] shift_left_amount;
    multiplexer_based_bit_shifter_left shift_left_inst (
        .data_in(shift_left_in),
        .shift_amount(shift_left_amount),
        .data_out(shift_left_out)
    );
    
    //-----------------------------------------------------------------
    // Instantiate the FPU absolute value unit.
    wire [79:0] abs_result;
    FPU_ABS_Unit abs_inst (
        .in(temp_fp),
        .out(abs_result)
    );
    
    //-----------------------------------------------------------------
    // Instantiate the IEEE754 rounding unit (extended precision).
    wire [79:0] round_result;
    reg [1:0] rounding_mode;
    ieee754_rounding_unit_extended round_inst (
        .clk(clk),
        .in(temp_fp),
        .mode(rounding_mode),
        .out(round_result)
    );
    
    //-----------------------------------------------------------------
    // Instantiate the IEEE754 normalizer.
    wire [79:0] norm_result;
    ieee754_normalizer_extended_precision norm_inst (
        .clk(clk),
        .ieee754_in(temp_fp),
        .ieee754_out(norm_result)
    );
    
    //-----------------------------------------------------------------
    // Main FSM: Fetch, decode, and execute microinstructions.
    always @(posedge clk or posedge reset) begin
        if (reset) begin
            state                <= STATE_IDLE;
            instruction_complete <= 1'b0;
            pc                   <= 16'd0;
            call_sp              <= 4'd0;
            cpu_data_out         <= 64'd0;
            temp_reg             <= 64'd0;
            loop_reg             <= 32'd0;
            math_const_index     <= 5'd0;
            temp_fp              <= 80'd0;
            temp_fp_a            <= 80'd0;
            temp_fp_b            <= 80'd0;
            fpu_invert_operand_b <= 1'b0;
            operand_a            <= 80'd0;
            operand_b            <= 80'd0;
            shift_left_in        <= 64'd0;
            shift_left_amount    <= 3'd0;
            rounding_mode        <= 2'd0;
            fpu_status_reg       <= 16'd0;
        end else begin
            case (state)
                STATE_IDLE: begin
                    if (start) begin
                        // Look up starting address using the micro_program_index.
                        pc <= micro_program_table[micro_program_index];
                        instruction_complete <= 1'b0;
                        call_sp <= 4'd0;
                        state <= STATE_FETCH;
                    end
                end
                
                STATE_FETCH: begin
                    microinstruction <= microcode_rom[pc];
                    state <= STATE_DECODE;
                end
                
                STATE_DECODE: begin
                    // (Additional decoding could occur here.)
                    state <= STATE_EXEC;
                end
                
                STATE_EXEC: begin
                    case (opcode)
                        `OPCODE_NOP: begin
                            pc <= pc + 1;
                        end
                        
                        `OPCODE_EXEC: begin
                            case (micro_op)
                                `MOP_LOAD: begin
                                    temp_reg <= cpu_data_in;
                                    pc <= next_addr;
                                end
                                
                                `MOP_STORE: begin
                                    cpu_data_out <= temp_reg;
                                    pc <= next_addr;
                                end
                                
                                `MOP_SET_CONST: begin
                                    math_const_index <= immediate[4:0];
                                    pc <= next_addr;
                                end
                                
                                `MOP_ACCESS_CONST: begin
                                    temp_fp <= math_const_out;
                                    pc <= next_addr;
                                end
                                
                                `MOP_ADD_SUB: begin
                                    fpu_invert_operand_b <= immediate[0];
                                    operand_a <= temp_fp_a;
                                    operand_b <= temp_fp_b;
                                    temp_fp <= addsub_result;
                                    pc <= next_addr;
                                end
                                
                                `MOP_SHIFT_LEFT_BIT: begin
                                    shift_left_amount <= immediate[2:0];
                                    shift_left_in <= temp_reg;
                                    temp_reg <= shift_left_out;
                                    pc <= next_addr;
                                end
                                
                                `MOP_LOOP_INIT: begin
                                    loop_reg <= {24'd0, immediate};
                                    pc <= next_addr;
                                end
                                
                                `MOP_LOOP_DEC: begin
                                    if (loop_reg != 0) begin
                                        loop_reg <= loop_reg - 1;
                                        pc <= next_addr; // Jump for another iteration.
                                    end else begin
                                        pc <= pc + 1;
                                    end
                                end
                                
                                `MOP_ABS: begin
                                    temp_fp <= abs_result;
                                    pc <= next_addr;
                                end
                                
                                `MOP_ROUND: begin
                                    rounding_mode <= immediate[1:0];
                                    temp_fp <= round_result;
                                    pc <= next_addr;
                                end
                                
                                `MOP_NORMALIZE: begin
                                    temp_fp <= norm_result;
                                    pc <= next_addr;
                                end
                                
                                `MOP_READ_STATUS: begin
                                    temp_reg <= {48'd0, fpu_status};
                                    pc <= next_addr;
                                end
                                
                                `MOP_READ_CONTROL: begin
                                    temp_reg <= {48'd0, fpu_control};
                                    pc <= next_addr;
                                end
                                
                                `MOP_READ_TAG: begin
                                    temp_reg <= {48'd0, fpu_tag};
                                    pc <= next_addr;
                                end
                                
                                `MOP_WRITE_STATUS: begin
                                    // Write lower 16 bits of temp_reg to FPU_Status.
                                    fpu_status_reg <= temp_reg[15:0];
                                    pc <= next_addr;
                                end
                                
                                default: begin
                                    pc <= next_addr;
                                end
                            endcase
                        end
                        
                        `OPCODE_JUMP: begin
                            pc <= next_addr;
                        end
                        
                        `OPCODE_CALL: begin
                            call_stack[call_sp] <= pc + 1;
                            call_sp <= call_sp + 1;
                            pc <= next_addr;
                        end
                        
                        `OPCODE_RET: begin
                            if (call_sp > 0) begin
                                call_sp <= call_sp - 1;
                                pc <= call_stack[call_sp - 1];
                            end else begin
                                pc <= 16'd0; // Error handling for empty call stack.
                            end
                        end
                        
                        `OPCODE_HALT: begin
                            instruction_complete <= 1'b1;
                            state <= STATE_IDLE;
                        end
                        
                        default: begin
                            pc <= next_addr;
                        end
                    endcase
                    if (opcode != `OPCODE_HALT)
                        state <= STATE_FETCH;
                end
                
                default: state <= STATE_IDLE;
            endcase
        end
    end
endmodule
